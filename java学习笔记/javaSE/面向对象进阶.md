# 面向对象进阶笔记



## 一、static

static静态修饰符，是java中的一个修饰符，可以修饰成员方法，成员变量

#### 1.**被static修饰的成员变量，叫做静态变量**

**特点：**

* 被该类所有的对象共享
* 跟对象无关，随着类的加载而加载，优先于对象存在
* 不属于对象，属于类。Student.name = "赋值"；
* 随着类的加载而加载，优先于对象存在

**调用方式：**

* 类名调用(推举)
* 对象名调用（静态的东西是不属于对象的）



#### 2.**被static修饰的成员方法，叫做静态方法**     

**特点：**

* 多用在测试类和工具类中
* javaBean类中很少用

**调用方法：**

* 类名调用（推举）
* 对象名调用



**工具类**：帮助我们做一些事情的，但不描述如何事物的类

**JavaBean类**： 用来描述一类事物的类。比如，Student，Teachar，Dog，Cat等

**测试类**：用来检查其他类是否书写正确，带有main方法的类，是程序的入口



#### 3.工具类的规则：

**类名要见名知意如** ：arrUtil操作数组的工具类

**私有化构造方法**：因为工具类是不描述任何事物的

**方法定义为静态：**getMax() ,getSum(),getMin()



#### 4.static的注意事项

* 静态方法只能访问静态变量和静态方法
* 非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法
* 静态方法中是没有this关键字的

​		**总结**：静态方法中只能访问静态

​		非静态方法中可以访问所有

​		静态方法中没有this关键字



this：表示当前调用者的地址值

这个this：是由虚拟机赋值

```java
public void shout(Student this){ //非静态方法形参有一个隐藏的Student this变量，由虚拟机来赋值
	System.out.println("this",this); //this是当前对象的地址值
	System.out.println(this.name,this.age);
	
}
```

1**总结**：在成员方法里面他是有一个隐藏的this的，不管成员变量和成员方法都会有this

***站在虚拟机设计者的角度来看***：

静态的东西都是共享的跟某一个对象没太大关系，所以静态方法里面没有this关键字

静态方法不能调用非静态(非共享) 的变量，因为静态方法里面没有this

非静态可以访问所有(静态的和非静态的) 如：this.静态方法



**静态存储位置在静态区（堆内）**

静态方法不能调用非静态的成员变量，调用静态方法是不实例化成员变量





#### 5.重新认识main方法

![](img\main方法.png)

* public :   被JVM调用，访问权限足够大
* static  : 被JVM调用，不用创建对象，直接类名访问
* void      ：被JVM调用，不需要要JVM返回值
* main   ：   一个通用的名称，虽然不是关键字，但是被JVM识别
* String[] args   :以前用于接收键盘录入数据的，现在没有（现在为了兼容以前的程序而保留着）





## 二、继承

面向对象三大特征之一

用来解决：多个对象减少代码重复的问题

**继承：**

* java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起继承的关系

```java
public class Student extends Person {}
```

* Student称为子类（派生类），Person称为父类（基类或超类）



**使用继承的好处：**

* 可以把多个子类中重复的代码抽取到父类中了，提高代码的复用性。
* 子类可以在父类的基础上，增加其他的功能，使子类更强大。



**继承需要学习的点：**

自己设计 和 使用别人的





#### **1、什么时候会用到继承？**

当类与类之间，存在相同(共性)的内容 ，并满足子类是父类中的一种（程序员和项目经理属于员工中），就可以考虑继承，来优化代码

![](img\设计继承结构.png)



设计继承类时要满足存在相同共性，子类是父类中的一种



**小结：**

​	继承是面向对象三大特征之一，可以类与类之间产生父子关系。

​	可以把多个子类重复的代码抽取到父类中，子类可以直接使用，减少代码的使用，提高代码的复用性

​	继承的格式：

```java
public class 子类 extends 父类 {}
```

​	子类可以得到父类的属性和行为，子类也可以使用。

​	子类可以在父类的基础上新增其他功能，子类更强大。





#### 2、继承的特点

**java当中只支持单继承，不支持多继承，但支持多层继承。**

单继承：一个子类只能继承一个父类

不支持多继承：子类不能同时继承多了父类

多层继承：子类A 继承父类B，父类B 继承父类 C ，B是A的直接父类，C是A的间接父类

每个类都直接或者间接的继承于Object

![](img\设计一个继承体系.png)



![](img\继承图2.png)

**总结：**

1.java只能单继承，不能多继承，但是可以多层继承。

2.java中所有的类都直接或者间接继承于Object类

3.子类只能访问父类中非私有的成员

4.要会独立完成继承体系的案例

​	



#### 3、子类到底能继承父类中的那些内容？（内存图/内存分析工具）126



误区1:父类私有的东西，子类就无法继承

误区2：父类中私有的成员，就被子类继承下来

* **内存图**

**继承下来**：父类私有的东西子类没有但是子类可以拷贝一份下来，就可以用了

**调用**：调用是不可以调私有的成员变量的

**结论**：不管什么样的修饰符之类都能继承下来（除了构造方法因为构造方法名字是类名）

**构造方法是否可以被继承：**构造方法不能被继承

![](img\gzff.png)

* **内存分析工具** hsdb



报错点Alt+回车：提示错误还可以补全错误





**虚方法表：**

![image-20221012141557770](img\image-20221012141557770.png)



**成员继承下来：**

|          |                                 |                                          |
| -------- | ------------------------------- | ---------------------------------------- |
| 构造方法 | 非私有  不能                    | private 不能                             |
| 成员变量 | 非私有 能                       | private 能（继承下来但是不能直接去使用） |
| 成员方法 | 非私有 能（父类的通过虚方法表） | private 不能                             |



#### 4、继承中：成员变量的访问特点

​	**就近原则：谁近就用谁**现在局部位置找，没有就去本类位置找成员变量，如果没有就去父类找，如果再没有就报错

![image-20221012144406341](img\image-20221012144406341.png)

**如果出现变量重名的情况：可以用关键字来区分**

![image-20221012144534271](img\image-20221012144534271.png)

**this:**指向本类成员变量

**super**：指向父类的成员变量



#### 5、继承中：成员方法的访问特点

直接调用满足就近原则：谁近，为就用谁

super调用，直接访问父类

this调用，直接访问本类



##### **1.方法的重写：**

当父类的方法不能满足之类的需求时，需要进行发放重写

**书写格式**

在继承体系中，子类出现了和父类一模一样的方法声明，我们就称子类的这个方法是重写的方法

**@Override重写注解**

1、@Override是放在重写后的方法上，校验子类重写是语法是否正确

2、加上注解后如果有红色波浪线，表示语法错误。

3、**建议重写方法都要加上@Override注解，代码安全，优雅！**



重写的本质：在虚方法表中，子类的重写的方法 ，会**覆盖虚方法表**里面的父类方法

![image-20221012151859807](img\image-20221012151859807.png)

![image-20221012152551164](img\image-20221012152551164.png)

#### 总结：

**1.继承中成员方法访问特点：**

​		this调用：就近原则。

​		super调用：直接找父类。

**2.什么是方法的重写？**

​		在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类的这个方法是重写方法。

**3.方法的重写建议加上那个注释，有什么好处？**

​		@Override注解可以校验重写是否正确，同时可读性好。

**4.重写方法有那些基本的要求？**

* 子类重写的方法尽量跟父类中的方法保持一致。
* 只有虚方法表里面的方法可以被重写（父类有这个方法可以视为虚方法，就可以重写）

**5.方法重写的本质？**

​		 覆盖虚方法表中的方法





#### 6、继承中：构造方法的访问特点

* **父类的构造方法是不能被子类继承的**

	![](img2\子类不能继承父类的构造方法.png)

* **之类中所有的构造方法默认先访问父类中的无参构造，再执行自己。**

​		因为子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，之类将		无法使用父类的数据

​		所有说子类初始化之前，一定要调用父类的构造方法完成父类的数据看见初始化。

* **怎么调用父类构造方法的？**

​		子类构造方法的第一行语句默认都是：super(),不写也存在，且必须在第一行。

​		如果想用父类有参构造。必须手动写super进行调用：super(参数，参数)；

![](img2\继承中构造方法的访问特点.png)



#### 7、this、super使用总结

* **this:理解为一个变量，表示当前方法调用者的地址值；**

	this.aet();调用本类的方法

​		this(...);调用本类的其他构造

​		this必须写在方法中的第一行

​	**把对象在内存中的结构打印出来**

```java
ClassLayout layout = ClassLayout.parseInstance(对象名)；
sout(layout.toPrintable());
```



* **super:代表父类存储空间**

​	super(...);调用父类的构造方法

​	super.eat();调用父类的成员方法

​	**细节：**

```java
public Student(){
//表示调用本类的其他构造方法
//细节：虚拟机就不会再添加super();
this(null,0);
}
```

**小练习：**

![](img2\练习题1.png)

![](img2\练习题2.png)







## 三、多态

#### 1.认识多态

遇到多代码中共性内容过多时我们可以使用继承来解决这个问题。



**多态指对象的多种形态**

**1.什么是多态？**

同类型的对象，表现出的不同的形态。

**2.多态的表现形式**

```java
父类类型 对象名称 = 子类对象；
```

**3.书写多态的前提条件**

* 有继承 / 实现关系
* 有父类引用指向子类对象  ：Fu f = new zi();
* 有方法重写（例如登录功能，为管理员的，和给用户的是不一样的）

```java
public static void register(person p){
	p.show
}
//当方法的参数是一个对象时，那么我们可以传递的值是这个对象的的所有的子类对象
```

**4.多态的好处？**

使用父类型作为参数，可以接收所有子类的对象，体现了多态的拓展和便利





#### 2.多态调用成员的特点



**Fu f = new Zi(); 多态的调用发法**

口诀：

注：左边父类，右边子类

* **变量的调用：编译看左边，运行也看左边**  

​	**编译看左边**：javac编译代码时，会看左边父类中有没有变量，如果有，编译成功，没有就编译失败。

**运行也看左边：**java运行代码时，实际获取的就是左边父类中成员变量的值

* **方法调用：编译看左边，运行看右边。**

​		**编译看左边：**javac编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，反之编译失败。

​		**运行看右边：**java运行代码时实际上运行的是子类中的方法。



**理解：//Animal a = new Dog();**

​			现在用a去调用变量和方法的，a 是Animal的类型的，所有默认都会从Ainmal这个类中去找的。

​			

//成员变量：在子类中的对象中，会把父类的成员变量也继承下来的。父：name 子：name

//成员发法：如果子类对方法进行了重写，那么虚方法表中是会把父类的方法覆盖的所以调用的方法是子类的。



#### 3.多态调用成员的内存图解

![](img2\多态调用成员变量的内存图.png)

**字节码文件**：在**方法区**中会先加载父类的类，再加载子类的类和虚方法表。

**Animal a = new Dog（）；**会在堆内存里面开辟一个的堆空间，用于存放自己成员变量的信息和父类成员变量的信息。

**sout（a.name）；** 这里的a 是Animal内型的所以会直接去Ainmal找这个变量



#### 4.多态的优势和他的弊端

Animal a = new Dog();

**.多态的优势**

* 在多态形势下，右边对象可以实现解耦合，便于拓展和维护。
* 定义一个方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的拓展型和便利。（记住）

泛型指元素的类型

**.多态的弊端**

* 不能去调用子类的特有功能（非重写的方法，父类没有的）(记住)

	a.特有方法（）；编译是好先检查父类是有有这个功能没有就报错

* 解决方案：

​		

​		a.变回子类的类型就好啦.

​		**细节**：转换时不能瞎转，原来是什么类型就转什么类型

​		Dog d = (Dog)a;强制转换

​		

* **很多时候我们不知道要转成什么类型就需要用代码判断**

​		instanceof关键字用于判断变量记录的对象是不是右边的类型，是就true。

```java
if(a instanceof Dog){
    Dog d = (Dog) a;
    d.特有方法();
}else if(a instanceof Cat){
	Cat c = (Cat) a;
    c.特有方法();
}else{
	sout("没有需要转换的类型");
}
```

​	

**JDK14新特性：**

​	合并写法：

```java
if(a instanceof Dog d){ //先判断a是否为Dog类型，是则强转成为Dog类型，转换之后变量名是 d
    d.特有方法();
}else if(a instanceof Cat c){
    c.特有方法();
}else{
	sout("没有需要转换的类型");
}
```



#### 引用数据类型的类型转换，有几种方式？

1，自动类型转换（子转父一般多态写法）。

2，强制类型转换（父转子）

**强制转换能解决什么问题？**

* 可以转换成真正的子类类型，从而调用子类的多有功能。
* 转换类型与真实对象类型不一致会报错（instanceof关键字结合if判断）；
* 转换的时候用instanceof关键字进行判断



#### 多态的综合练习：

![](img2\多态练习题1.png)



## 四、包、linal，权限修饰符，代码块

## 五、抽象类

## 六、接口

## 七、内部类

## 八、拼图游戏练习